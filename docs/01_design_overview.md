# オセロAI設計仕様書

## プロジェクト概要

TD(λ)-Leafによる自己学習を用いた高性能オセロAIの開発

### 目標
- 自己対戦による強化学習で強力なオセロAIを構築
- パターン評価に基づく高速な評価関数
- 100万局の学習で実用的な強さを達成

---

## 1. アーキテクチャ

### 1.1 全体構成

```
┌─────────────────────────────────────┐
│ Python学習環境                       │
│ - 学習制御                          │
│ - パラメータ管理                     │
│ - 統計・可視化                       │
└──────────┬──────────────────────────┘
           │ PyO3
┌──────────▼──────────────────────────┐
│ Rustコア                             │
│ - BitBoard盤面表現                   │
│ - パターン抽出（4方向回転）           │
│ - 評価関数                           │
│ - MTD(f)探索 + 反復深化              │
│ - TD(λ)-Leaf学習                    │
│ - 自己対戦エンジン                   │
└─────────────────────────────────────┘
```

### 1.2 言語選択の理由

**Rust**:
- BitBoard操作が高速（u64ビット演算）
- メモリ安全性（長時間学習での安定性）
- PyO3による優れたPython連携
- ARM64（OCI Ampere A1）への対応

---

## 2. パターン評価システム

### 2.1 パターン定義

詳細は`patterns.md`および`patterns.csv`を参照。

- **パターン数**: 14個（P01-P14）
- **総セル数**: 124セル
- **エントリ数**: 約1,440万エントリ

### 2.2 ステージ分割

- **ステージ数**: 30ステージ
- **分割方式**: 2手ごと
  - Stage 0: 0-1手目
  - Stage 1: 2-3手目
  - ...
  - Stage 29: 58-59手目

### 2.3 対称性の扱い

**回転のみ考慮**（反転は考慮しない）:
- 0°回転
- 90°回転
- 180°回転
- 270°回転

**テーブル共有**:
```
保持: 0°用テーブルのみ（メモリ約57MB）

使用時:
- 0°/180°回転  → table[index(黒=1, 白=2)]
- 90°/270°回転 → table[index(黒=2, 白=1)]  // 白黒反転
```

**理由**: 初期盤面の中央配置が90°回転+白黒反転で0°と一致するため

### 2.4 スコア表現

```rust
type Score = u16;  // 0-65535

// 変換定数
const SCALE: f32 = 256.0;
const CENTER: f32 = 32768.0;

// 変換関数
石差 = (score - 32768.0) / 256.0
score = clamp(石差 × 256.0 + 32768.0, 0.0, 65535.0)
```

**値域**:
- u16: 0 → 石差: -128.0
- u16: 32768 → 石差: 0.0
- u16: 65535 → 石差: +127.996

**理由**: 整数演算による高速化、十分な精度

---

## 3. 評価関数

### 3.1 計算方法

```
1. 盤面を4方向に回転
2. 各方向で14パターンを抽出（合計56パターンインスタンス）
3. 現在のステージに応じたテーブルから値を取得
4. 全パターンスコアを合計
5. 現手番が白なら符号反転
```

### 3.2 疑似コード

```rust
fn evaluate(board: &Board, stage: usize) -> f32 {
    let mut sum = 0.0;

    // 4方向の回転
    for rotation in [0, 90, 180, 270] {
        let rotated = board.rotate(rotation);

        // 白黒反転フラグ
        let swap = (rotation == 90 || rotation == 270);

        // 14パターン抽出
        for pattern in &PATTERNS {
            let index = extract_index(rotated, pattern, swap);
            let score = u16_to_score(table[pattern.id][stage][index]);
            sum += score;
        }
    }

    // 手番考慮
    if board.is_white_turn() {
        -sum
    } else {
        sum
    }
}
```

---

## 4. 探索アルゴリズム

### 4.1 MTD(f)探索

**特徴**:
- AlphaBetaの高速化版
- 置換表必須
- 反復深化と組み合わせて使用

**時間制限**: 15ms/手

### 4.2 反復深化

```
depth = 1から開始
while 時間制限内:
    result = mtdf(board, depth, guess)
    guess = result.score
    depth += 1
```

### 4.3 完全読み

- **開始タイミング**: 残り14手
- **手法**: AlphaBetaによる完全探索
- **理由**: 14手（約16,384局面）なら現実的

### 4.4 置換表

```
サイズ: 128-256MB
エントリ数: 約200-400万エントリ
ハッシュ: Zobrist Hashing
```

**エントリ構造**:
```rust
struct TTEntry {
    hash: u64,        // Zobrist hash
    depth: i8,        // 探索深さ
    bound: Bound,     // Lower/Upper/Exact
    score: i16,       // 評価値
    best_move: Move,  // 最善手
}
```

### 4.5 Move Ordering

優先順位:
1. 置換表の最善手
2. 角を取る手
3. 角の隣を避ける
4. 評価値の高い手（簡易評価）
5. その他の手

---

## 5. 学習アルゴリズム

### 5.1 TD(λ)-Leaf

**概要**:
- 各手でMTD(f)探索を実行
- 葉ノードの評価値を学習に使用
- λ=0.3でEligibility Traceを使用

### 5.2 更新タイミング

- **頻度**: 1局終了ごと
- **方向**: 終局から逆向きに更新

### 5.3 Eligibility Trace

```rust
// 各手で
trace[entry] = λ × trace[entry] + 1.0

// 終局時（逆順）
for t in (0..60).rev() {
    td_error = target - current_value
    update = α × td_error × trace[entry]
    // Adam optimizerを適用
}
```

### 5.4 TD誤差計算

```
target_t =
  if t == 最終手:
    実際の石差
  else:
    V(s_{t+1}) + (1-λ) × (V(s_{t+1}) - V(s_t))
```

---

## 6. Adamオプティマイザ

### 6.1 パラメータ

```
学習率 α: 0.025
β1: 0.9     // 1次モーメント減衰率
β2: 0.999   // 2次モーメント減衰率
ε: 1e-8     // 数値安定性
```

### 6.2 状態管理

各パターンテーブルエントリごとに:
```rust
struct AdamState {
    m: Vec<f32>,  // 1次モーメント（勾配の移動平均）
    v: Vec<f32>,  // 2次モーメント（勾配二乗の移動平均）
    t: u64,       // タイムステップ
}
```

### 6.3 更新式

```
m_t = β1 × m_{t-1} + (1-β1) × gradient
v_t = β2 × v_{t-1} + (1-β2) × gradient²

m_hat = m_t / (1 - β1^t)
v_hat = v_t / (1 - β2^t)

param_new = param - α × m_hat / (√v_hat + ε)
```

---

## 7. 自己対戦設定

### 7.1 ε-greedy探索

```
0-30万局:   ε = 0.15 (15%ランダム手)
30-70万局:  ε = 0.05 (5%ランダム手)
70-100万局: ε = 0.0  (常に最善手)
```

**目的**:
- 初期: 多様な序盤パターンの探索
- 中期: 有望な定石への収束
- 後期: 最適戦略の精緻化

### 7.2 ランダム手の選択

- 合法手から一様ランダムに選択
- 探索は実行しない（高速化）

---

## 8. 初期化

### 8.1 テーブル初期値

全エントリ: `32768`（石差0）

**理由**:
- ニュートラルなスタート
- 対称性を保つ
- 学習の安定性

### 8.2 Adam状態

```
m: 全て0
v: 全て0
t: 0
```

---

## 9. メモリ使用量

```
パターンテーブル (u16):        57 MB
Adam 1次モーメント (f32):     114 MB
Adam 2次モーメント (f32):     114 MB
置換表 (128-256MB):       128-256 MB
────────────────────────────────────
合計:                     413-541 MB
```

OCI Always Free (24GB RAM) で十分余裕あり。

---

## 10. 学習規模

### 10.1 目標

- **局数**: 100万局
- **総手数**: 約6,000万手
- **総更新数**: 約33.6億回（56パターン/手）
- **平均更新/エントリ**: 約233回

### 10.2 時間見積もり

```
探索時間: 15ms/手（平均）
並列度: 4コア

理論時間: 6,000万手 × 15ms ÷ 4 = 62.5時間

実効時間: 50-60時間（約2.5日）
  ※終盤の高速化による時間短縮を考慮
```

---

## 11. チェックポイント

### 11.1 頻度

10万局ごとに保存（全10回）

### 11.2 保存内容

1. パターンテーブル（全14パターン × 30ステージ）
2. Adam状態（m, v, t）
3. メタデータ:
   - 現在の局数
   - 学習経過時間
   - 統計情報

### 11.3 ファイル形式

```
checkpoint_NNNNNN.bin
  where NNNNNN = 局数（6桁、0埋め）

例: checkpoint_000000.bin (初期状態)
    checkpoint_100000.bin (10万局後)
    checkpoint_1000000.bin (100万局後)
```

---

## 12. ログ・監視

### 12.1 リアルタイム統計（100局ごと）

- 平均石差
- 黒勝率/白勝率/引分率
- 平均手数
- 経過時間

### 12.2 詳細統計（1万局ごと）

- 評価値の分布（平均、標準偏差、最大/最小）
- 平均探索深さ（序盤/中盤/終盤別）
- 平均探索時間
- 置換表ヒット率

### 12.3 チェックポイント時

- 完全な統計サマリ
- テーブル保存
- 進捗レポート

---

## 13. 実装環境

### 13.1 ハードウェア

```
プラットフォーム: Oracle Cloud Infrastructure (OCI)
インスタンス: Always Free - Ampere A1
CPU: 4 OCPU (ARM64)
メモリ: 24 GB
ストレージ: 最大200 GB
```

### 13.2 ソフトウェア

```
OS: Ubuntu 24.04 (ARM64)
言語: Rust (最新安定版)
Python: 3.10+ (学習制御用)
連携: PyO3
```

### 13.3 月間利用制限

```
OCPU時間: 3,000時間/月
メモリGB時間: 18,000 GB時間/月

→ 4 OCPU × 24GB を720時間（30日）連続稼働可能
→ 100万局学習（50-60時間）は月間の8%程度
```

---

## 14. プロジェクト構成（予定）

```
othello-ai/
├── Cargo.toml              # Rust依存関係
├── pyproject.toml          # Python依存関係
├── README.md
├── docs/
│   ├── design_overview.md      # 本ドキュメント
│   ├── technical_specs.md      # 技術詳細仕様
│   └── parameters.md           # パラメータ一覧
├── data/
│   ├── patterns.md             # パターン定義
│   └── patterns.csv
├── src/                    # Rustソースコード
│   ├── lib.rs
│   ├── board.rs            # BitBoard実装
│   ├── pattern.rs          # パターン抽出
│   ├── evaluator.rs        # 評価関数
│   ├── search.rs           # MTD(f)探索
│   ├── td_learn.rs         # TD(λ)-Leaf学習
│   ├── adam.rs             # Adamオプティマイザ
│   └── python.rs           # PyO3バインディング
├── python/                 # Python学習スクリプト
│   ├── train.py            # メイン学習ループ
│   ├── monitor.py          # 監視・可視化
│   └── evaluate.py         # 評価スクリプト
└── checkpoints/            # チェックポイント保存先
```

---

## 15. 開発フェーズ

### Phase 1: 基礎実装（1-2週間）
- BitBoard実装
- パターン抽出
- 基本評価関数
- 単体テスト

### Phase 2: 探索実装（1-2週間）
- AlphaBeta探索
- 置換表
- MTD(f)移行
- Move Ordering
- 完全読み

### Phase 3: 学習実装（1週間）
- TD(λ)-Leaf
- Adamオプティマイザ
- Eligibility Trace
- 自己対戦エンジン

### Phase 4: 統合・調整（1週間）
- Python連携
- チェックポイント機構
- ログ・監視
- デバッグ・最適化

### Phase 5: 学習実行（2.5日）
- 100万局学習
- 監視・調整
- 結果分析

---

## 16. 成功の評価基準

### 16.1 技術指標

- 学習完了: 100万局
- 平均更新回数: 200回以上/エントリ
- 探索速度: 15ms/手以内
- メモリ使用: 600MB以内

### 16.2 性能指標

- ランダムプレイヤーに対する勝率: 99%以上
- 簡易評価関数（角・辺のみ）に対する勝率: 90%以上
- 自己対戦での平均石差: 収束傾向

---

## 17. 次のステップ

1. 技術詳細仕様書の確認
2. パラメータ一覧の確認
3. 実装開始
4. 単体テストの作成
5. 統合テスト
6. 学習実行
