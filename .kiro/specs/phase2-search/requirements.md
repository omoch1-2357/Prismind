# Requirements Document

## プロジェクト説明（入力）
README.mdとその他のドキュメントに基づいて、Phase 2の実装を行って。

## イントロダクション

本要件定義書は、オセロAIプロジェクトのPhase 2（探索アルゴリズム実装）における機能要件を定義する。Phase 1で確立した高速なBitBoard操作とパターン評価システムを基盤として、Phase 2ではNegamax、AlphaBeta、MTD(f)探索アルゴリズムを実装し、15ms/手の高速探索を実現する。

Phase 2の実装範囲:
- Negamax探索アルゴリズムの基本実装
- AlphaBeta枝刈りによる探索効率化
- MTD(f)探索による最適化
- 置換表（Transposition Table）とZobristハッシュ
- ムーブオーダリング戦略（置換表最善手、角優先、X打ち回避）
- 反復深化（Iterative Deepening）フレームワーク
- 完全読み（残り14手からの終局探索）
- 時間管理と探索制御
- パフォーマンス測定とベンチマーク

## 要件

### 要件 1: Negamax探索の基本実装

**目的:** 探索アルゴリズムの開発者として、深さ制限付きNegamax探索を実装したい。これにより、ゲーム木を再帰的に探索し、最善手と評価値を取得する基盤を確立する。

#### 受入基準

1. The Negamax探索関数 shall 現在の盤面、深さ、評価関数を受け取り、最善評価値を返す
2. When 深さが0に到達した際、the Negamax探索関数 shall 評価関数を呼び出して葉ノードの評価値を返す
3. When ゲーム終了状態に到達した際、the Negamax探索関数 shall 最終スコア×100を評価値として返す
4. The Negamax探索関数 shall 全合法手について再帰的に探索し、最大評価値（相手視点では最小）を選択する
5. When パス状態の際、the Negamax探索関数 shall 盤面を反転して相手番として探索を継続する
6. The Negamax探索関数 shall 符号反転により手番の視点を統一する（Negamaxの原則）
7. The Negamax探索関数 shall 最善手の位置情報をOption<u8>として返す

### 要件 2: AlphaBeta枝刈りの実装

**目的:** 探索最適化の開発者として、AlphaBeta枝刈りを実装し探索効率を向上したい。これにより、探索ノード数を大幅に削減し、より深い探索を可能にする。

#### 受入基準

1. The AlphaBeta探索関数 shall alpha値とbeta値を引数として受け取る
2. When 探索中の評価値がbeta値以上になった際、the AlphaBeta探索関数 shall 即座に枝刈り（beta cut）を実行する
3. When 評価値がalphaを超えた際、the AlphaBeta探索関数 shall alpha値を更新する
4. The AlphaBeta探索関数 shall fail-soft実装でalpha-beta範囲外の正確な評価値を返す
5. The AlphaBeta探索関数 shall Negamaxと同じ結果を返すことを保証する（正当性検証）
6. The AlphaBeta探索関数 shall 探索ノード数をNegamaxの20-30%に削減する（ムーブオーダリング併用時）

### 要件 3: 置換表の実装

**目的:** 探索システムの開発者として、評価済み局面を記憶する置換表を実装したい。これにより、同一局面の再評価を回避し、探索を高速化する。

#### 受入基準

1. The 置換表構造体 shall 128-256MBのメモリを使用し、約200-400万エントリを保持する
2. The 置換表エントリ shall Zobristハッシュ、探索深さ、評価値、境界タイプ、最善手、世代情報を含む
3. When 局面を探索する際、the 置換表 shall Zobristハッシュで高速に既存エントリを検索する
4. If 置換表に有効なエントリが存在する場合、the 探索関数 shall 深さが十分なら置換表の評価値を使用する
5. The 置換表 shall Exact、Lower Bound、Upper Boundの3種類の境界タイプを管理する
6. When 新しいエントリを保存する際、the 置換表 shall 深さと世代を考慮した置換戦略を適用する
7. The 置換表 shall 世代管理により古いエントリを効率的に更新する
8. When 置換表エントリを使用する際、the 探索関数 shall ハッシュ値の完全一致を確認する

### 要件 4: Zobristハッシュの実装

**目的:** 置換表の開発者として、盤面を一意に識別するZobristハッシュを実装したい。これにより、高速な局面照合と衝突の最小化を実現する。

#### 受入基準

1. The Zobristハッシュテーブル shall 初期化時に黒石64個、白石64個、手番1個の乱数を生成する
2. The Zobristハッシュ関数 shall 盤面の全石位置と手番をXOR演算でハッシュ値に変換する
3. The Zobristハッシュ shall 同じ盤面に対して常に同じハッシュ値を返す（決定性）
4. The Zobristハッシュ shall 石の配置が1つ異なる盤面に対して高確率で異なるハッシュ値を返す
5. When 着手を実行する際、the Zobristハッシュ shall 差分更新（XOR演算）で効率的に計算する
6. The Zobristハッシュ shall 固定シード値により再現可能な乱数列を生成する

### 要件 5: MTD(f)探索の実装

**目的:** 高性能探索の開発者として、MTD(f)アルゴリズムを実装し探索効率をさらに向上したい。これにより、AlphaBetaより少ない探索ノード数で最善手を発見する。

#### 受入基準

1. The MTD(f)探索関数 shall 初期推測値（guess）を受け取り、反復的にゼロ幅探索を実行する
2. When 探索結果がbeta未満の際、the MTD(f)関数 shall upper boundを更新する
3. When 探索結果がbeta以上の際、the MTD(f)関数 shall lower boundを更新する
4. The MTD(f)関数 shall lower boundとupper boundが一致するまで探索を繰り返す
5. The MTD(f)関数 shall 置換表と組み合わせて使用することを前提とする
6. The MTD(f)関数 shall AlphaBetaと同じ最善手と評価値を返すことを保証する
7. The MTD(f)関数 shall 探索ノード数をAlphaBetaの70-80%に削減する

### 要件 6: ムーブオーダリングの実装

**目的:** 探索最適化の開発者として、合法手の評価順序を最適化したい。これにより、枝刈り効率を最大化し、探索時間を短縮する。

#### 受入基準

1. The ムーブオーダリング関数 shall 置換表の最善手を最優先で評価する
2. The ムーブオーダリング関数 shall 角を取る手を高優先度で評価する
3. The ムーブオーダリング関数 shall 角の隣（X打ち）を低優先度で評価する
4. The ムーブオーダリング関数 shall 辺の手を中優先度で評価する
5. The ムーブオーダリング関数 shall 優先度順にソートされた合法手リストを返す
6. When ムーブオーダリングを適用した際、the AlphaBeta探索 shall 枝刈り効率が20-30%向上する

### 要件 7: 反復深化フレームワークの実装

**目的:** 探索制御の開発者として、反復深化により時間制限内で最善手を発見したい。これにより、浅い探索から徐々に深化し、時間切れでも最善手を返せる。

#### 受入基準

1. The 反復深化関数 shall 深さ1から開始し、時間制限まで深さを1ずつ増やす
2. When 各深さの探索が完了した際、the 反復深化関数 shall 最善手と評価値を更新する
3. The 反復深化関数 shall 前回の探索結果をMTD(f)の初期推測値として使用する
4. When 時間制限の80%を使用した際、the 反復深化関数 shall 次の深さの探索をスキップする
5. If 時間制限に到達した場合、the 反復深化関数 shall 最後に完了した深さの最善手を返す
6. The 反復深化関数 shall 探索開始から経過時間を継続的に監視する
7. The 反復深化関数 shall 到達深さと最終評価値を返す

### 要件 8: 完全読みの実装

**目的:** 終盤探索の開発者として、空きマス数14以下から完全読みを実装したい。これにより、終局までの最適手順を正確に計算する。

#### 受入基準

1. When 空きマス数が14以下の際、the 探索関数 shall 完全読みモードに切り替える
2. The 完全読み関数 shall AlphaBeta探索で終局までの全手順を探索する
3. When 終局に到達した際、the 完全読み関数 shall 最終石差×100を評価値として返す
4. The 完全読み関数 shall 通常探索と同じムーブオーダリングを使用する
5. The 完全読み関数 shall 置換表を活用して探索を高速化する
6. The 完全読み関数 shall 深さ14で平均100ms以内に完全読みを完了する

### 要件 9: 時間管理と探索制御

**目的:** 探索システムの開発者として、時間制限内で探索を制御したい。これにより、15ms/手の性能要件を満たし、実用的なゲームプレイを実現する。

#### 受入基準

1. The 探索制御関数 shall 時間制限（デフォルト15ms）を引数として受け取る
2. The 探索制御関数 shall 探索開始時にタイムスタンプを記録する
3. When 反復深化の各イテレーション後、the 探索制御関数 shall 経過時間を確認する
4. If 経過時間が時間制限の80%を超えた場合、the 探索制御関数 shall 次の深さの探索をスキップする
5. The 探索制御関数 shall 時間切れ時に最後に完了した深さの最善手を返す
6. The 探索制御関数 shall 平均15ms以内に最善手を返す（100手の平均）
7. The 探索制御関数 shall 序盤・中盤・終盤で探索深さを調整する

### 要件 10: 探索統計の収集

**目的:** パフォーマンス分析者として、探索の詳細統計を収集したい。これにより、探索効率の分析と最適化の方向性を決定する。

#### 受入基準

1. The 探索統計構造体 shall 探索ノード数、置換表ヒット数、枝刈り回数を記録する
2. The 探索統計構造体 shall 到達深さ、評価関数呼び出し回数、探索時間を記録する
3. When 探索完了時、the 探索関数 shall 統計情報を返す
4. The 探索統計 shall 置換表ヒット率（ヒット数÷総アクセス数）を計算する
5. The 探索統計 shall 枝刈り効率（枝刈り回数÷探索ノード数）を計算する
6. The 探索統計 shall デバッグモードで詳細ログを出力する

### 要件 11: 探索アルゴリズムの統合API

**目的:** Phase 3学習システムの開発者として、探索アルゴリズムの統合APIを提供したい。これにより、学習フェーズで容易に探索を利用できる。

#### 受入基準

1. The Search構造体 shall 評価関数、置換表、Zobristハッシュを内部状態として保持する
2. The Search::new()関数 shall 評価関数とメモリサイズを引数として初期化する
3. The Search::search()関数 shall 盤面、時間制限を受け取り、最善手と評価値を返す
4. The Search::search()関数 shall 反復深化+MTD(f)+ムーブオーダリングを組み合わせて使用する
5. When 探索中にエラーが発生した場合、the Search shall Result型でエラーを返す
6. The Search shall スレッドセーフでない（Phase 2では単一スレッド動作）
7. The Search shall Phase 1のBitBoardとEvaluatorを直接利用する

### 要件 12: 探索結果の表現

**目的:** 探索結果の利用者として、探索結果を明確に表現したい。これにより、最善手、評価値、探索統計を一貫した形式で取得する。

#### 受入基準

1. The SearchResult構造体 shall 最善手（u8位置）、評価値（f32）、到達深さ（u8）を含む
2. The SearchResult構造体 shall 探索ノード数、置換表ヒット数、探索時間を含む
3. The SearchResult構造体 shall PV（Principal Variation）ラインを格納する（オプション）
4. When 最善手が存在しない場合、the SearchResult shall None値を返す
5. The SearchResult shall Display traitを実装し、人間可読な形式で出力する

### 要件 13: エラーハンドリング

**目的:** 探索システムの開発者として、探索中のエラーを適切にハンドリングしたい。これにより、システムの安定性と診断性を向上させる。

#### 受入基準

1. The SearchErrorカスタムエラー型 shall 置換表メモリ不足、評価関数エラー、時間切れを表現する
2. When 置換表のメモリ確保に失敗した際、the Search::new() shall SearchError::MemoryAllocationを返す
3. When 評価関数が失敗した際、the 探索関数 shall SearchError::EvaluationErrorを返す
4. The SearchError shall thiserrorクレートを使用して実装する
5. The SearchError shall 詳細なエラーメッセージとコンテキストを提供する

### 要件 14: 探索アルゴリズムのユニットテスト

**目的:** 品質保証担当者として、探索アルゴリズムの正当性を検証したい。これにより、各アルゴリズムが期待通りに動作することを保証する。

#### 受入基準

1. The Negamax探索 shall 深さ1で全合法手を評価し、最善手を返すテストを含む
2. The AlphaBeta探索 shall Negamaxと同じ結果を返すことを検証するテストを含む
3. The 置換表 shall 同一局面で既存エントリを正しく取得するテストを含む
4. The Zobristハッシュ shall 同じ盤面で同じハッシュ値を返すテストを含む
5. The MTD(f)探索 shall AlphaBetaと同じ最善手を返すテストを含む
6. The ムーブオーダリング shall 置換表最善手が最初に評価されるテストを含む
7. The 反復深化 shall 時間制限内に最善手を返すテストを含む
8. The 完全読み shall 既知の終盤局面で正解手を返すテストを含む

### 要件 15: 探索パフォーマンス要件

**目的:** システムアーキテクトとして、Phase 2の探索が性能要件を満たすことを保証したい。これにより、100万局の学習を現実的な時間で完了できる。

#### 受入基準

1. The 探索システム shall 平均15ms以内に最善手を返す（100手の平均、序盤中盤）
2. The AlphaBeta探索 shall 深さ6で平均10ms以内に探索を完了する（初期盤面）
3. The MTD(f)探索 shall AlphaBetaより20-30%少ない探索ノード数で最善手を発見する
4. The 置換表 shall ヒット率50%以上を達成する（中盤以降）
5. The 完全読み shall 深さ14で平均100ms以内に完了する
6. The ムーブオーダリング shall 枝刈り効率を20-30%向上させる
7. The 探索システム shall メモリ使用量350MB以内に収める（置換表256MB + 評価テーブル70MB含む）

### 要件 16: ARM64探索最適化

**目的:** パフォーマンスエンジニアとして、ARM64アーキテクチャ向けに探索を最適化したい。これにより、OCI Ampere A1の性能を最大限活用する。

#### 受入基準

1. The 置換表 shall キャッシュライン（64バイト）にアライメントされたメモリを使用する
2. The Zobristハッシュ shall ARM64の高速XOR演算を活用する
3. The ムーブオーダリング shall ブランチレス実装で分岐予測ミスを最小化する
4. The 探索ループ shall プリフェッチディレクティブで次の局面をプリフェッチする（オプション）
5. The 探索システム shall ARM64とx86_64の両方で動作することを保証する（条件付きコンパイル）

### 要件 17: ベンチマークとプロファイリング

**目的:** パフォーマンス分析者として、探索システムのベンチマークを実施したい。これにより、最適化の効果を定量的に評価する。

#### 受入基準

1. The 探索ベンチマーク shall Criterion crateで実装する
2. The 探索ベンチマーク shall 初期盤面での深さ1-6の探索時間を測定する
3. The 探索ベンチマーク shall 中盤局面での深さ6-8の探索時間を測定する
4. The 探索ベンチマーク shall 置換表ヒット率、枝刈り効率を測定する
5. The 探索ベンチマーク shall perfツールでキャッシュミス率を測定する（Linux環境）
6. The 探索ベンチマーク shall 1秒あたりの探索ノード数（nps）を測定する
7. The 探索ベンチマーク shall GitHub Actions CI/CDで自動実行する

## 非機能要件

### NFR-1: Phase 1 APIとの整合性
The Phase 2探索実装 shall Phase 1のBitBoard、Evaluator、Patternの公開APIを変更せずに利用する

### NFR-2: メモリ効率
The 探索システム shall 総メモリ使用量400MB以内に収める（Phase 1の70MB + 置換表256MB + その他）

### NFR-3: スレッド安全性（将来対応）
The Phase 2実装 shall 単一スレッド動作を前提とし、Phase 4での並列化に備えて状態の分離を考慮する

### NFR-4: Phase 3学習への引き継ぎ
The 探索システム shall 学習システムが容易に統合できるAPIを提供する（Search::search()、SearchResult）

### NFR-5: ドキュメントとテスト
The 全公開関数 shall Rustdocコメントで目的、引数、戻り値、使用例を記述する

### NFR-6: 段階的実装と検証
The Phase 2実装 shall Negamax→AlphaBeta→MTD(f)の順に段階的に実装し、各段階でベンチマークを実施する

## 補足

### Phase 2完了の定義
- 全17要件の受入基準を満たす
- 全ユニットテストが成功する（探索の正当性、パフォーマンス要件）
- 平均15ms/手の性能要件を達成（100手の平均）
- 置換表ヒット率50%以上を確認
- Criterion crateとperfツールによるベンチマーク完備

### Phase 3への引き継ぎ事項
- Search構造体の公開API
- SearchResult構造体のフォーマット
- 探索統計の収集方法
- パフォーマンスレポート（探索時間、ノード数、ヒット率、枝刈り効率）
- 最適化実装ガイド（ARM64専用最適化、プリフェッチ戦略）

### 依存関係
- Phase 1完了（BitBoard、Evaluator、Pattern、評価テーブル）
- Rust 1.70以上の開発環境
- ARM64環境（OCI Ampere A1）でのベンチマーク
- perfツール（Linuxパフォーマンス測定）のインストール

### 推奨実装順序
1. Week 1: Negamax基本実装（要件1、11、12）
2. Week 2: AlphaBeta枝刈り、ムーブオーダリング（要件2、6、14）
3. Week 3: 置換表、Zobristハッシュ（要件3、4、14）
4. Week 4: MTD(f)、反復深化、完全読み（要件5、7、8、14）
5. Week 5: 時間管理、統合、ベンチマーク（要件9、10、15、17）

### パフォーマンス目標サマリ
- 探索時間: 平均15ms/手（序盤中盤）
- AlphaBeta深さ6: 10ms以内（初期盤面）
- 完全読み深さ14: 100ms以内
- 置換表ヒット率: 50%以上（中盤以降）
- 枝刈り効率向上: 20-30%（ムーブオーダリング適用時）
- メモリ使用量: 400MB以内（Phase 1含む）
