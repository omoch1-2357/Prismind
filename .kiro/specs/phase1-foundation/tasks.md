# 実装タスク

## タスク概要

Phase 1の基礎実装を、BitBoard盤面表現からパターン評価システムまで段階的に構築します。全16要件（要件1-16）をカバーし、各タスクは1-3時間で完了可能な粒度に分割されています。ARM64最適化と段階的ベンチマークを組み込み、早期にボトルネックを特定します。

---

## タスクリスト

- [x] 1. プロジェクト初期化とコア型定義
- [x] 1.1 (P) Cargoプロジェクト作成と依存関係設定
  - Cargo.tomlでRust 1.70+プロジェクト初期化
  - csv、serde、thiserror、criterionクレートを追加
  - リリースビルド最適化設定（opt-level=3、lto="fat"）
  - ARM64最適化フラグ設定（target-cpu="neoverse-n1", target-feature="+neon,+crc,+crypto"）
  - ARM64とx86_64の互換性確認
  - _Requirements: 13.3, 13.5, NFR-2, 16.1, 16.2_

- [x] 1.2 (P) BitBoard構造体とColor列挙型の定義
  - BitBoard構造体を#[repr(C, align(8))]で定義
  - black、white（各u64）、turn（Color）、move_count（u8）フィールド
  - Color列挙型をBlack/White値で定義し、opposite()メソッド実装
  - Clone、Copy、Debug、PartialEq、Eqトレイトを派生
  - メモリサイズが16バイト以内であることを確認
  - _Requirements: 1.1, 1.2, 13.1, 1.6_

- [x] 1.3 (P) BitBoard初期化と基本操作
  - BitBoard::new()で初期盤面（D4白、E4黒、D5黒、E5白）を設定
  - current_player()とopponent()メソッドでビットマスク取得
  - flip()メソッドで白黒反転を実装
  - 初期盤面の正当性を検証するユニットテスト
  - _Requirements: 1.3, 1.4, 1.5, 14.1_

- [x] 2. BitBoard回転操作とARM64最適化
- [x] 2.1 (P) 基本回転関数の実装
  - rotate_90()で90度回転（反時計回り）を実装
  - rotate_180()でu64::reverse_bits()を使用（ARM64のREV命令活用）
  - rotate_270()で270度回転を実装
  - 各関数が黒白両方のビットマスクを正しく変換することを確認
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 16.3_

- [x] 2.2 (P) 回転操作の検証とベンチマーク
  - 4回の90度回転で元の盤面に戻ることを確認するテスト
  - 既知盤面での視覚的検証テスト
  - Criterion crateで回転操作のベンチマーク実施
  - 目標: rotate_180 200ns以内（ARM64 REV命令効果の確認）
  - 回転後の盤面が元のゲーム状態を保存することの検証
  - _Requirements: 5.5, 5.6, 15.5, NFR-5_

- [x] 3. 合法手生成と着手実行
- [x] 3.1 8方向ビットシフト補助関数
  - shift()関数で8方向のビットシフトを実装
  - 端のマスク処理（左右端、上下端）を正しく適用
  - DIRECTIONS定数配列で8方向を定義
  - 各方向のシフトが正しく動作することをユニットテスト
  - _Requirements: 2.2, 2.4_

- [x] 3.2 合法手生成の実装とARM64最適化
  - legal_moves()関数で全合法手をビットマスクとして返す
  - 8方向それぞれについて挟める相手の石を検出
  - ARM64のCLZ/CTZ命令を活用（trailing_zeros(), leading_zeros()）
  - 合法手なしの場合に0x0000000000000000を返す
  - 既知の盤面状態での期待される合法手を検証するテスト
  - _Requirements: 2.1, 2.3, 2.5, 14.2, 16.4_

- [x] 3.3 合法手生成のベンチマーク（Phase 1A完了時点）
  - Criterion crateでlegal_moves()のベンチマーク実施
  - 目標: 500ns以内（ARM64実測値ベース）
  - 1000回実行の平均時間・標準偏差・p99パーセンタイル測定
  - ボトルネック特定（必要に応じて最適化）
  - _Requirements: 2.6, 15.1, NFR-5_

- [x] 3.4 着手実行とエラーハンドリング
  - make_move()関数で指定位置に石を配置
  - 8方向の石返し処理を実装（find_flipped_in_direction）
  - UndoInfo構造体で元の状態を保持
  - GameErrorカスタムエラー型（IllegalMove、OutOfBounds）を定義
  - _Requirements: 3.1, 3.2, 3.4, 3.5, 13.5_

- [x] 3.5 着手実行の完全性検証とベンチマーク
  - 石の反転が正しく適用されることを検証
  - 手番が相手に切り替わることを確認
  - undo_move()関数で元の状態に復元
  - 非合法な位置への着手でエラーを返すことをテスト
  - Criterion crateでmake_move()のベンチマーク実施
  - 目標: 1.5μs以内
  - _Requirements: 3.3, 3.4, 3.5, 3.6, NFR-5_

- [x] 4. ゲーム状態管理
- [x] 4.1 (P) ゲーム終了判定とスコア計算
  - GameState列挙型（Playing、Pass、GameOver）を定義
  - check_game_state()で現在のゲーム状態を判定
  - final_score()で黒石数と白石数の差を計算
  - 手数カウンタの管理（0-60手）を実装
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5_

- [x] 4.2 (P) ゲーム状態判定の検証
  - 両者とも合法手がない場合にゲーム終了を返すテスト
  - 全64マスが埋まった際にゲーム終了を返すテスト
  - パス状態の正しい判定テスト
  - 最終スコアが-64～+64の範囲内であることを確認
  - _Requirements: 4.1, 4.2, 4.3, 4.4_

- [x] 5. パターン定義の読み込みと最適化
- [x] 5.1 Pattern構造体とCSV読み込み
  - Pattern構造体を#[repr(C, align(8))]で定義
  - id（u8）、k（u8）、positions（[u8; 10]固定長配列）フィールド
  - load_patterns()関数でpatterns.csvを読み込み
  - serde Deserializeトレイトを使用したCSVパース
  - 座標→ビット位置変換（A1=0、H8=63）を実装
  - _Requirements: 6.1, 6.2, 6.4, 6.6, 13.6_

- [x] 5.2 パターン定義の検証とエラーハンドリング
  - 各パターンのセル位置が0-63の範囲内であることを検証
  - パターン数が14個であることを確認
  - PatternErrorカスタムエラー型を定義
  - ファイル不存在や形式エラーでエラーメッセージを表示
  - メモリレイアウト確認（ヒープアロケーション回避）
  - _Requirements: 6.3, 6.4, 6.5, NFR-4_

- [x] 6. パターンインデックス抽出とブランチレス最適化
- [x] 6.1 3進数インデックス計算
  - extract_index()関数で3進数（0=空、1=黒、2=白）計算
  - パターンの各セルについて石の状態をビットマスクから取得
  - 白黒反転フラグ対応（swap_colors引数）
  - ブランチレス実装で分岐予測ミスを最小化
  - 計算結果が0～3^k-1の範囲内であることを保証
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.6_

- [x] 6.2 パターンインデックスの決定性検証
  - 同一盤面・同一パターンで常に同じインデックスを返すテスト
  - 既知盤面での期待インデックス値テスト
  - 白黒反転フラグの動作確認テスト
  - 対称性検証（回転後のインデックス一致）
  - _Requirements: 7.5, 14.3_

- [ ] 7. 4方向パターン抽出システムとキャッシュ効率化
- [ ] 7.1 全パターン抽出関数の実装
  - extract_all_patterns()関数で4方向（0°、90°、180°、270°）に回転
  - 各回転方向について14パターンのインデックスを抽出（合計56個）
  - 90°/270°回転時に白黒反転フラグをtrueに設定
  - 0°/180°回転時に白黒反転フラグをfalseに設定
  - _Requirements: 8.1, 8.2, 8.3, 8.4_

- [ ] 7.2 パターン抽出のベンチマークとキャッシュ測定（Phase 1B完了時点）
  - 56個のインデックスが配列として正しい順序で返されることを確認
  - 回転方向×パターンIDの順序検証テスト
  - 対称な盤面で56個のインデックスが期待通りか確認
  - Criterion crateでベンチマーク実施
  - 目標: 25μs以内（キャッシュミス率を考慮）
  - perfツールでキャッシュミス率測定
  - _Requirements: 8.5, 8.6, 15.2, 15.6, NFR-5_

- [ ] 8. 評価テーブル管理（SoA形式）
- [ ] 8.1 (P) EvaluationTable構造体の実装（SoA形式）
  - Structure of Arrays形式で[ステージ][平坦化配列]の2次元構造を定義
  - pattern_offsets配列で各パターンの開始位置を管理
  - EvaluationTable::new()で全エントリを32768に初期化
  - get()メソッドで評価値取得（offset計算含む）
  - set()メソッドで評価値設定（Phase 3学習用）
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.6, 9.7_

- [ ] 8.2 (P) 評価テーブルのメモリ管理とアライメント
  - 各パターンについて3^k個のエントリを割り当て
  - 30ステージそれぞれに独立したテーブルを持つ
  - 同じステージの全パターンデータを連続メモリ配置
  - memory_usage()でメモリ使用量を計算
  - 総メモリ使用量が80MB以内であることを確認
  - _Requirements: 9.5, 9.6, 13.2_

- [ ] 9. スコア型変換とNEON最適化
- [ ] 9.1 (P) u16とf32の相互変換
  - u16_to_score()で(value - 32768.0) / 256.0計算
  - score_to_u16()でclamp(score × 256.0 + 32768.0, 0.0, 65535.0)計算
  - u16値0を石差-128.0にマッピング
  - u16値32768を石差0.0にマッピング
  - u16値65535を石差+127.996にマッピング
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5_

- [ ] 9.2 (P) スコア変換の境界値検証とSIMD最適化
  - 境界値（0、32768、65535）での変換テスト
  - 往復変換（u16→f32→u16）で元の値に戻ることを確認
  - 範囲外の値に対するclamp動作の検証
  - 浮動小数点演算の精度確認
  - ARM NEON SIMD版実装（u16_to_score_simd、8個同時変換）
  - SIMD版のベンチマーク比較
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 16.5_

- [ ] 10. ステージ管理
- [ ] 10.1 (P) ステージ計算関数
  - calculate_stage()で手数÷2をステージ番号として返す
  - 手数60の場合にステージ29を返す
  - 0-29の範囲内の整数を返すことを保証
  - 各ステージごとに独立した評価テーブルへのアクセスを可能にする
  - _Requirements: 12.1, 12.2, 12.3, 12.5_

- [ ] 10.2 (P) ステージ計算の境界値検証
  - 0-1手でステージ0を返すテスト
  - 2-3手でステージ1を返すテスト
  - 58-59手でステージ29を返すテスト
  - 手数60でステージ29を返すテスト
  - _Requirements: 12.1, 12.2, 12.4_

- [ ] 11. 基本評価関数とプリフェッチ最適化
- [ ] 11.1 Evaluator構造体の初期化
  - Evaluator構造体（patterns、table（SoA形式））を定義
  - Evaluator::new()でpatterns.csvを読み込み
  - EvaluationTableをSoA形式で初期化
  - パターン配列を[Pattern; 14]として保持
  - _Requirements: 11.1, 11.2_

- [ ] 11.2 評価関数の実装とプリフェッチ
  - evaluate()メソッドで盤面の評価値を計算
  - ステージを手数÷2で計算
  - 56個のパターンインスタンスから評価値を取得し合計
  - 各パターンインスタンスのu16値をf32石差に変換してから合計
  - 次回アクセス位置をプリフェッチ（ARM64のprefetchディレクティブ）
  - _Requirements: 11.1, 11.4, 11.7, 16.6_

- [ ] 11.3 評価関数のベンチマークとキャッシュ測定（Phase 1C完了時点）
  - 現在の手番が白の際に合計評価値の符号を反転
  - 初期盤面に対して評価値0.0付近を返すことを確認
  - 対称な盤面での評価値一致テスト
  - Criterion crateで評価関数のベンチマーク実施
  - 目標: 35μs以内（プリフェッチとSoA最適化）
  - perfツールでキャッシュミス率測定
  - 目標: キャッシュミス率30-40%以下
  - プロファイリングデータ収集（perf stat、flamegraph）
  - _Requirements: 11.3, 11.5, 11.6, 15.3, 15.6, NFR-5_

- [ ] 12. 統合とパブリックAPI
- [ ] 12.1 モジュール構成とlib.rs整備
  - board.rs、moves.rs、rotation.rs、pattern.rs、evaluator.rs、arm64.rsモジュールを作成
  - arm64.rsにARM64専用最適化を集約（NEON SIMD、プリフェッチ）
  - 各モジュールの公開インターフェースを定義
  - lib.rsで全モジュールを統合
  - Rustdocコメントで全公開関数の目的と使用例を記述
  - _Requirements: 13.3, NFR-3_

- [ ] 12.2 パブリックAPIの統合テスト
  - BitBoard操作から評価関数までの一連のフロー検証
  - Pattern読み込みからEvaluator初期化までの統合テスト
  - 着手実行→合法手再計算→ゲーム状態判定のフロー検証
  - エラーハンドリングパスの統合テスト
  - _Requirements: 13.5, NFR-4_

- [ ] 13. デバッグ支援機能
- [ ] 13.1 (P) BitBoard表示機能
  - display()関数で盤面を8×8グリッドで表示
  - 黒石、白石、空マスを視覚的に区別
  - 合法手の位置をオプション表示
  - デバッグモードで中間状態をログ出力
  - _Requirements: 14.4, 14.5_

- [ ] 14. 総合パフォーマンス検証
- [ ] 14.1 (P) コアオペレーションの最終ベンチマーク
  - legal_moves()が平均500ナノ秒以内で実行されることを確認
  - make_move()が平均1.5マイクロ秒以内で実行されることを確認
  - rotate_180()が平均200ナノ秒以内で実行されることを確認（ARM64 REV命令効果）
  - Criterion crateで最終マイクロベンチマーク実施
  - 1000回実行の平均時間・標準偏差・p99パーセンタイル測定
  - _Requirements: 15.1, 15.4, 15.5_

- [ ] 14.2 (P) 評価システムの最終パフォーマンス検証
  - extract_all_patterns()が平均25マイクロ秒以内で実行されることを確認
  - evaluate()が平均35マイクロ秒以内で実行されることを確認
  - perfツールで最終キャッシュミス率測定（目標30-40%以下）
  - メモリ使用量の監視と80MB以内の確認
  - ARM64最適化の効果測定（NEON SIMD、プリフェッチ）
  - _Requirements: 15.2, 15.3, 15.6, 13.2, 16.5, 16.6_

- [ ] 14.3 (P) パフォーマンスレポート作成
  - 全ベンチマーク結果の集約
  - 実測値とキャッシュミス率のサマリ
  - ARM64最適化の効果分析
  - ボトルネック分析と改善提案
  - Phase 2への引き継ぎ事項の整理
  - _Requirements: NFR-5_

- [ ] 15. 最終検証とドキュメント整備
- [ ] 15.1 (P) 全ユニットテストの実行と修正
  - 全モジュールのユニットテストを実行
  - カバレッジ確認（全要件の受入基準がテストされているか）
  - テスト失敗箇所の修正とリグレッション防止
  - CI/CD環境での自動テスト実行設定
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.6_

- [ ] 15.2 (P) Phase 2引き継ぎドキュメント作成
  - BitBoard操作の全APIリスト
  - 評価テーブル構造体（SoA形式）の仕様
  - パターン抽出関数のインターフェース
  - 基本評価関数の使用例とパフォーマンス特性
  - ARM64最適化実装ガイド
  - ベンチマーク環境設定（Criterion、perfツール）
  - _Requirements: NFR-3_

---

## タスク実行ガイド

### 並列実行可能なタスク
`(P)`マークが付いているタスクは並列実行可能です。同じ主要タスク内でも独立した作業であれば並行して進められます。

### 依存関係の注意点
- タスク3（合法手生成）はタスク1（BitBoard定義）完了後に開始
- タスク7（パターン抽出）はタスク2（回転）、タスク5（パターン定義）、タスク6（インデックス計算）完了後に開始
- タスク11（評価関数）はタスク7（パターン抽出）、タスク8（評価テーブル）、タスク9（スコア変換）、タスク10（ステージ）完了後に開始
- タスク12（統合）は全コア機能（タスク1-11）完了後に開始

### 段階的ベンチマーク戦略

**Phase 1A（Week 1）: BitBoard基礎**
- タスク3.3完了時: legal_moves()ベンチマーク（目標500ns）
- タスク3.5完了時: make_move()ベンチマーク（目標1.5μs）
- タスク2.2完了時: rotate操作ベンチマーク（目標200ns）
- 早期ボトルネック特定と対処

**Phase 1B（Week 2）: パターンシステム**
- タスク7.2完了時: extract_all_patterns()ベンチマーク（目標25μs）
- perfツールでキャッシュミス率測定
- SoA形式の効果確認

**Phase 1C（Week 3）: 評価システム**
- タスク11.3完了時: evaluate()ベンチマーク（目標35μs）
- キャッシュミス率測定（目標30-40%以下）
- プリフェッチ効果の検証

**Phase 1D（Week 4）: 最終検証**
- タスク14.1-14.3: 総合パフォーマンス測定
- ARM64最適化効果の総合評価
- Phase 2引き継ぎドキュメント作成

### パフォーマンス目標（修正版）

各タスクで以下の性能要件を満たすこと：
- 合法手生成: 500ns以内（ARM64実測値ベース）
- パターン抽出（56個）: 25μs以内（キャッシュミス率30-40%想定）
- 評価関数: 35μs以内（プリフェッチとSoA最適化）
- 着手実行: 1.5μs以内
- BitBoard回転: 200ns以内（ARM64 REV命令活用）
- キャッシュミス率: 30-40%以下（perfツールで測定）

### メモリ目標

- BitBoard: 16バイト/盤面
- Pattern構造体: 24バイト（固定長配列、ヒープアロケーション回避）
- 評価テーブル（SoA形式）: 80MB以内（パディング込み）
- 総使用量: 100MB以内

### ARM64最適化チェックリスト

- [ ] Cargo.tomlにtarget-cpu="neoverse-n1"設定
- [ ] Cargo.tomlにtarget-feature="+neon,+crc,+crypto"設定
- [ ] rotate_180()でu64::reverse_bits()使用（REV命令）
- [ ] legal_moves()でtrailing_zeros()/leading_zeros()使用（CLZ/CTZ命令）
- [ ] u16→f32変換のNEON SIMD版実装（オプション）
- [ ] evaluate()でprefetchディレクティブ使用

### perfツール使用例

```bash
# キャッシュミス率の測定
perf stat -e cycles,instructions,cache-references,cache-misses,branches,branch-misses \
    cargo bench --bench evaluate_bench

# 期待される出力
# cache-misses: ~30-40% of cache-references
# IPC (instructions per cycle): ~0.85-1.0
```

---

**タスク総数**: 15主要タスク、47サブタスク
**全要件カバー**: 16要件（要件1-16）、5非機能要件（NFR-1～NFR-5）
**平均タスク時間**: 1-3時間/サブタスク
**総所要時間**: 約4週間（週30-40時間稼働想定）
