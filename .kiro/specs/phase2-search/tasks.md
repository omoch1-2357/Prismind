# 実装タスク

## タスク概要

Phase 2の探索アルゴリズム実装を、Negamax基本実装からMTD(f)最適化まで段階的に構築します。全17要件をカバーし、各タスクは1-3時間で完了可能な粒度に分割されています。Phase 1の高速な基盤（合法手生成22ns、評価関数35μs）を活用し、15ms/手の高性能探索エンジンを実現します。

---

## タスクリスト

- [x] 1. 探索システム基盤の構築
- [x] 1.1 (P) Zobristハッシュの実装
  - ZobristTable構造体を定義（black: [u64; 64], white: [u64; 64], turn: u64）
  - 固定シード値で乱数を生成（再現性確保）
  - hash()メソッドでBitBoardから64ビットハッシュ値を計算
  - XOR演算で石の配置と手番をハッシュ化
  - 同じ盤面で常に同じハッシュ値を返すことを検証するテスト
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.6_

- [x] 1.2 (P) 置換表構造体の実装
  - TTEntry構造体を定義（hash: u64, depth: i8, bound: Bound, score: i16, best_move: u8, age: u8）
  - Bound列挙型を定義（Exact、Lower、Upper）
  - TranspositionTable構造体を定義（entries: Vec<Option<TTEntry>>, size: usize, current_age: u8）
  - new()メソッドで128-256MBのメモリを確保
  - 2の累乗サイズでインデックス計算をビットマスク最適化
  - メモリ確保失敗時にSearchError::MemoryAllocationを返す
  - _Requirements: 3.1, 3.2, 13.1, 13.2_

- [x] 1.3 (P) 置換表の基本操作
  - probe()メソッドでZobristハッシュから既存エントリを検索
  - hash値の完全一致を確認（衝突検出）
  - store()メソッドで新しいエントリを保存
  - 置換戦略を実装（深さ優先 + 世代管理）
  - increment_age()メソッドで世代を更新
  - 同一局面で既存エントリを取得するテスト
  - _Requirements: 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [x] 1.4 (P) SearchError型とSearchResult構造体
  - SearchError列挙型を定義（MemoryAllocation、EvaluationError、TimeoutExceeded、InvalidBoardState）
  - thiserrorクレートで詳細なエラーメッセージを実装
  - SearchResult構造体を定義（best_move: Option<u8>, score: f32, depth: u8, nodes_searched: u64, tt_hits: u64, elapsed_ms: u64, pv: Option<Vec<u8>>）
  - tt_hit_rate()メソッドでヒット率を計算
  - Display traitを実装して人間可読な形式で出力
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 13.1, 13.4, 13.5_

- [x] 2. Negamax探索の基本実装
- [x] 2.1 Negamax関数の実装
  - negamax()関数を実装（board: &BitBoard, depth: i32, evaluator: &Evaluator）
  - 深さ0で評価関数を呼び出して葉ノードの評価値を返す
  - ゲーム終了状態で最終スコア×100を返す
  - 全合法手について再帰的に探索し、最大評価値を選択
  - 符号反転により手番の視点を統一（Negamaxの原則）
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.6_

- [x] 2.2 Negamaxのパス処理と最善手返却
  - パス状態の際に盤面を反転して相手番として探索を継続
  - 最善手の位置情報をOption<u8>として返す
  - 探索ノード数をカウント（統計収集）
  - 深さ1で全合法手を評価し最善手を返すテスト
  - 初期盤面で4手の合法手を正しく評価することを確認
  - _Requirements: 1.5, 1.7, 10.1, 10.2, 14.1_

- [x] 3. AlphaBeta枝刈りの実装
- [x] 3.1 AlphaBeta関数の基本構造
  - alpha_beta()関数を実装（board: &mut BitBoard, depth: i32, alpha: i32, beta: i32, evaluator: &Evaluator, tt: &mut TranspositionTable, zobrist: &ZobristTable）
  - alpha値とbeta値を引数として受け取る
  - 評価値がbeta以上でbeta cutを実行
  - 評価値がalphaを超えた際にalpha値を更新
  - fail-soft実装でalpha-beta範囲外の正確な評価値を返す
  - _Requirements: 2.1, 2.2, 2.3, 2.4_

- [x] 3.2 AlphaBetaと置換表の統合
  - 探索開始時に置換表をプローブ
  - 深さが十分なら置換表の評価値を使用
  - 境界タイプ（Exact、Lower、Upper）に応じて枝刈りを適用
  - 探索完了時に置換表にエントリを保存
  - AlphaBetaがNegamaxと同じ最善手を返すことを検証するテスト
  - 探索ノード数がNegamaxの20-30%に削減されることを確認
  - _Requirements: 2.5, 2.6, 3.3, 3.4, 3.5, 14.2_

- [ ] 4. ムーブオーダリングの実装
- [ ] 4.1 (P) 静的ムーブオーダリング関数
  - order_moves()関数を実装（moves: u64, tt_best_move: Option<u8>）
  - 置換表の最善手を最優先で評価
  - 角を取る手を高優先度で評価（0, 7, 56, 63）
  - 角の隣（X打ち）を低優先度で評価（1, 8, 9, 6, 14, 15, 48, 49, 54, 55, 57, 62）
  - 辺の手を中優先度で評価
  - 優先度順にソートされた合法手リスト（Vec<u8>）を返す
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5_

- [ ] 4.2 (P) AlphaBetaにムーブオーダリングを適用
  - AlphaBeta探索のループ前にorder_moves()を呼び出し
  - ムーブオーダリング適用時に枝刈り効率が20-30%向上することを確認
  - 置換表最善手が最初に評価されることをテスト
  - 初期盤面での探索時間短縮効果を測定
  - _Requirements: 6.6, 14.6_

- [ ] 5. MTD(f)探索の実装
- [ ] 5.1 MTD(f)関数の基本構造
  - mtdf()関数を実装（board: &mut BitBoard, depth: i32, guess: i32, evaluator: &Evaluator, tt: &mut TranspositionTable, zobrist: &ZobristTable）
  - 初期推測値（guess）を受け取り、反復的にゼロ幅探索を実行
  - 探索結果がbeta未満の際にupper boundを更新
  - 探索結果がbeta以上の際にlower boundを更新
  - lower boundとupper boundが一致するまで探索を繰り返す
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5_

- [ ] 5.2 MTD(f)の正当性検証と効率測定
  - MTD(f)がAlphaBetaと同じ最善手と評価値を返すことを保証するテスト
  - 探索ノード数がAlphaBetaの70-80%に削減されることを確認
  - 通常2-3パス、最悪5-15パスで収束することを検証
  - 初期推測値が悪い場合の収束遅延を測定
  - _Requirements: 5.6, 5.7, 14.5_

- [ ] 6. 反復深化フレームワークの実装
- [ ] 6.1 反復深化関数の基本構造
  - iterative_deepening()関数を実装（board: &mut BitBoard, time_limit_ms: u64, evaluator: &Evaluator, tt: &mut TranspositionTable, zobrist: &ZobristTable）
  - 深さ1から開始し、時間制限まで深さを1ずつ増やす
  - 各深さの探索完了時に最善手と評価値を更新
  - 前回の探索結果をMTD(f)の初期推測値として使用
  - 探索開始からの経過時間を継続的に監視
  - _Requirements: 7.1, 7.2, 7.3, 7.6_

- [ ] 6.2 時間管理と探索制御
  - 時間制限の80%を使用した際に次の深さの探索をスキップ
  - 時間制限到達時に最後に完了した深さの最善手を返す
  - 到達深さと最終評価値を返す
  - 時間制限内に最善手を返すテスト
  - 平均15ms以内に最善手を返すことを確認（100手の平均）
  - _Requirements: 7.4, 7.5, 7.7, 9.6, 14.7_

- [ ] 7. 完全読みの実装
- [ ] 7.1 完全読み関数の実装
  - complete_search()関数を実装（board: &mut BitBoard, alpha: i32, beta: i32, tt: &mut TranspositionTable, zobrist: &ZobristTable）
  - 空きマス数14以下の検出（board.move_count >= 46）
  - AlphaBeta探索で終局までの全手順を探索
  - 終局到達時に最終石差×100を評価値として返す
  - 通常探索と同じムーブオーダリングを使用
  - _Requirements: 8.1, 8.2, 8.3, 8.4_

- [ ] 7.2 完全読みの性能検証
  - 置換表を活用して探索を高速化
  - 深さ14で平均100ms以内に完全読みを完了することを確認
  - 既知の終盤局面で正解手を返すテスト
  - 時間超過時のヒューリスティック評価へのフォールバック
  - _Requirements: 8.5, 8.6, 14.8_

- [ ] 8. Search統合APIの実装
- [ ] 8.1 Search構造体の初期化
  - Search構造体を定義（evaluator: Evaluator, transposition_table: TranspositionTable, zobrist: ZobristTable）
  - Search::new()関数で評価関数とメモリサイズを引数として初期化
  - 置換表サイズが128-256MBの範囲内であることを検証
  - Phase 1のBitBoardとEvaluatorを直接利用
  - 初期化失敗時にResult型でエラーを返す
  - _Requirements: 11.1, 11.2, 11.7, 13.2_

- [ ] 8.2 Search::search()メソッドの実装
  - search()メソッドを実装（board: &BitBoard, time_limit_ms: u64）
  - 探索開始時に置換表の世代を更新（increment_age）
  - 空きマス数14以下で完全読みモードに切り替え
  - それ以外は反復深化+MTD(f)+ムーブオーダリングを組み合わせて使用
  - SearchResultを返す（最善手、評価値、到達深さ、探索統計）
  - _Requirements: 11.3, 11.4, 11.5_

- [ ] 8.3 探索統計の収集
  - 探索ノード数、置換表ヒット数、枝刈り回数を記録
  - 到達深さ、評価関数呼び出し回数、探索時間を記録
  - 置換表ヒット率（ヒット数÷総アクセス数）を計算
  - 枝刈り効率（枝刈り回数÷探索ノード数）を計算
  - デバッグモードで詳細ログを出力
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 11.6_

- [ ] 9. ARM64探索最適化
- [ ] 9.1 (P) 置換表のキャッシュラインアライメント
  - TTEntryを64バイトにアライメント（#[repr(C, align(64))]）
  - Vec<TTEntry>をBox::new_uninit_slice()で確保
  - キャッシュミス率の改善効果を測定
  - ARM64とx86_64の両方で動作することを保証（条件付きコンパイル）
  - _Requirements: 16.1, 16.2, 16.5_

- [ ] 9.2 (P) ムーブオーダリングのブランチレス実装
  - 分岐予測ミスを最小化するブランチレス実装
  - ビット演算で角、X打ち、辺の判定を最適化
  - プリフェッチディレクティブで次の局面をプリフェッチ（オプション）
  - ARM64とx86_64での性能比較
  - _Requirements: 16.3, 16.4_

- [ ] 10. ベンチマークとプロファイリング
- [ ] 10.1 (P) 探索ベンチマークの実装
  - Criterion crateで探索ベンチマークを実装
  - 初期盤面での深さ1-6の探索時間を測定（目標: 深さ6で10ms以内）
  - 中盤局面での深さ6-8の探索時間を測定（目標: 深さ6で15ms以内）
  - 置換表ヒット率、枝刈り効率を測定
  - 1秒あたりの探索ノード数（nps）を測定
  - _Requirements: 17.1, 17.2, 17.3, 17.4, 17.6, 15.2_

- [ ] 10.2 (P) perfツールによる性能測定
  - perfツールでキャッシュミス率を測定（Linux環境）
  - 分岐予測ミス率を測定
  - 目標: キャッシュミス率50%以下、分岐予測ミス率1%以下
  - GitHub Actions CI/CDで自動実行するワークフローを追加
  - ARM64とx86_64の性能比較レポートを作成
  - _Requirements: 17.5, 17.7, NFR-6_

- [ ] 11. 統合テストとドキュメント
- [ ] 11.1 探索アルゴリズムのユニットテスト
  - Negamax探索が深さ1で全合法手を評価し最善手を返すテスト
  - AlphaBeta探索がNegamaxと同じ結果を返すテスト
  - 置換表が同一局面で既存エントリを正しく取得するテスト
  - Zobristハッシュが同じ盤面で同じハッシュ値を返すテスト
  - MTD(f)探索がAlphaBetaと同じ最善手を返すテスト
  - ムーブオーダリングで置換表最善手が最初に評価されるテスト
  - 反復深化が時間制限内に最善手を返すテスト
  - 完全読みが既知の終盤局面で正解手を返すテスト
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 11.2 探索パフォーマンス要件の検証
  - 探索システムが平均15ms以内に最善手を返すことを確認（100手の平均、序盤中盤）
  - AlphaBeta探索が深さ6で平均10ms以内に探索を完了することを確認（初期盤面）
  - MTD(f)探索がAlphaBetaより20-30%少ない探索ノード数で最善手を発見することを確認
  - 置換表がヒット率50%以上を達成することを確認（中盤以降）
  - 完全読みが深さ14で平均100ms以内に完了することを確認
  - ムーブオーダリングが枝刈り効率を20-30%向上させることを確認
  - 探索システムがメモリ使用量300MB以内に収めることを確認（置換表256MB + 評価テーブル70MB含む）
  - _Requirements: 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7_

- [ ] 11.3 Phase 3への引き継ぎドキュメント作成
  - Search::new()とSearch::search() APIの使用例を記述
  - SearchResult構造体のフォーマットと統計フィールドの説明
  - 探索統計のロギング方法とベストプラクティス
  - ARM64最適化の有効化方法と性能特性
  - Phase 3学習システムでの統合例（自己対戦ループ）
  - パフォーマンスレポート（探索時間、ノード数、ヒット率、枝刈り効率）
  - _Requirements: NFR-3, NFR-4, NFR-5, NFR-6_

---

## タスク実行ガイド

### 並列実行可能なタスク
`(P)`マークが付いているタスクは並列実行可能です。同じ主要タスク内でも独立した作業であれば並行して進められます。

### 推奨実装順序
1. Week 1: Negamax基本実装（タスク1、2）
   - Zobristハッシュ、置換表、SearchError/SearchResult、Negamax探索
   - 早期検証: Negamax正当性テスト、置換表動作確認

2. Week 2: AlphaBeta枝刈り、ムーブオーダリング（タスク3、4）
   - AlphaBeta実装、置換表統合、ムーブオーダリング
   - 早期検証: AlphaBeta-Negamax同値性、枝刈り効率測定

3. Week 3-4: MTD(f)、反復深化、完全読み（タスク5、6、7）
   - MTD(f)実装、反復深化フレームワーク、完全読み
   - 早期検証: MTD(f)-AlphaBeta同値性、時間管理、完全読み正当性

4. Week 5: 統合、最適化、ベンチマーク（タスク8、9、10、11）
   - Search統合API、ARM64最適化、ベンチマーク、ドキュメント
   - 最終検証: 全パフォーマンス要件達成確認

### 依存関係の注意点
- タスク2（Negamax）はタスク1.1-1.4（基盤）完了後に開始
- タスク3（AlphaBeta）はタスク1.3（置換表）、タスク2（Negamax）完了後に開始
- タスク4.2（AlphaBetaとムーブオーダリング統合）はタスク3、4.1完了後に開始
- タスク5（MTD(f)）はタスク3（AlphaBeta）、タスク1.3（置換表）完了後に開始
- タスク6（反復深化）はタスク5（MTD(f)）完了後に開始
- タスク7（完全読み）はタスク3（AlphaBeta）完了後に開始（MTD(f)と並列可能）
- タスク8（Search統合API）は全アルゴリズム（タスク2-7）完了後に開始
- タスク9（ARM64最適化）、タスク10（ベンチマーク）はタスク8完了後に開始可能
- タスク11（統合テスト、ドキュメント）は全タスク完了後に実施

### パフォーマンス目標

| 項目 | 目標値 | 検証タスク |
|------|--------|-----------|
| 平均探索時間（序盤中盤） | 15ms以内 | 11.2 |
| AlphaBeta深さ6（初期盤面） | 10ms以内 | 11.2 |
| MTD(f)探索ノード数削減 | AlphaBetaの70-80% | 5.2, 11.2 |
| 置換表ヒット率（中盤） | 50%以上 | 11.2 |
| 完全読み（深さ14） | 100ms以内 | 7.2, 11.2 |
| メモリ使用量 | 300MB以内 | 11.2 |
| 枝刈り効率向上（ムーブオーダリング） | 20-30% | 4.2, 11.2 |

### メモリ目標

- 置換表: 128-256MB（約5.3M-10.6Mエントリ）
- TTEntry: 24バイト（hash 8B + depth 1B + bound 1B + score 2B + best_move 1B + age 1B + padding 10B）
- Phase 1評価テーブル: 70MB
- 総使用量: 200-350MB（Phase 1含む）

### ARM64最適化チェックリスト

- [ ] Zobristハッシュ: ARM64の高速XOR演算活用
- [ ] 置換表: キャッシュライン（64バイト）アライメント
- [ ] ムーブオーダリング: ブランチレス実装で分岐予測ミスを最小化
- [ ] 探索ループ: プリフェッチディレクティブで次の局面をプリフェッチ（オプション）
- [ ] 条件付きコンパイル: ARM64とx86_64の両方で動作保証

---

**タスク総数**: 11主要タスク、30サブタスク
**全要件カバー**: 17要件（要件1-17）、6非機能要件（NFR-1～NFR-6）
**平均タスク時間**: 1-3時間/サブタスク
**総所要時間**: 約5週間（週30-40時間稼働想定）
