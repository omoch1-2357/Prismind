# Requirements Document

## プロジェクト説明（入力）
README.mdとその他のドキュメントに基づいて、Phase 1の実装を行って。

## イントロダクション

本要件定義書は、オセロAIプロジェクトのPhase 1（基礎実装）における機能要件を定義する。Phase 1では、高速なビットボード表現、パターン抽出機構、および基本的な評価関数を実装し、後続フェーズ（探索、学習）の基盤を確立する。

Phase 1の実装範囲:
- BitBoard による盤面表現とゲームルール実装
- 14パターン × 30ステージのパターン抽出システム
- 対称性を考慮した評価関数の基本構造
- パターン定義の読み込みと管理
- ARM64（Ampere A1）アーキテクチャに最適化されたメモリレイアウト

## 要件

### 要件 1: BitBoard盤面表現

**目的:** ゲーム開発者として、高速なビット演算により効率的にオセロの盤面を表現・操作したい。これにより、後続の探索・学習フェーズで高いパフォーマンスを実現する。

#### 受入基準

1. The BitBoard構造体 shall 黒石と白石をそれぞれu64型ビットマスクで表現する
2. The BitBoard構造体 shall 現在の手番（黒/白）を管理する
3. When 新しいゲームを開始する際、the BitBoard構造体 shall 初期盤面（D4白、E4黒、D5黒、E5白）を正しく設定する
4. The BitBoard構造体 shall 8×8マス（64マス）をビット位置0-63にマッピングする（A1=0, B1=1, ..., H8=63）
5. The BitBoard構造体 shall 盤面の白黒反転操作を提供する（手番交代時に使用）
6. The BitBoard構造体 shall 8バイトアライメントで定義し、キャッシュライン効率を最適化する

### 要件 2: 合法手生成

**目的:** ゲーム実装者として、与えられた盤面状態から全ての合法手を高速に生成したい。これにより、探索アルゴリズムの基礎を提供する。

#### 受入基準

1. When 盤面と手番が与えられた際、the 合法手生成関数 shall 全ての合法手をビットマスクとして返す
2. The 合法手生成関数 shall 8方向（上下左右斜め）それぞれについて挟める相手の石を検出する
3. If 合法手が存在しない場合、the 合法手生成関数 shall 空のビットマスク（0x0000000000000000）を返す
4. The 合法手生成関数 shall ビット演算による効率的な実装を使用する
5. The 合法手生成関数 shall 実行時間500ナノ秒以内で結果を返す（ARM64実測値ベース）
6. The 合法手生成関数 shall ARM64のCLZ（Count Leading Zeros）命令を活用する

### 要件 3: 着手実行と石の返転

**目的:** ゲーム実装者として、指定された位置に石を置き、挟んだ相手の石を正しく返したい。これにより、ゲームの進行を実現する。

#### 受入基準

1. When 合法手の位置が指定された際、the 着手実行関数 shall 指定位置に現手番の石を配置する
2. The 着手実行関数 shall 8方向それぞれについて挟まれた相手の石を検出し、自分の石に反転する
3. When 石の反転が完了した際、the 着手実行関数 shall 手番を相手に切り替える
4. The 着手実行関数 shall 着手前の状態を復元可能な情報を保持する（undo機能のため）
5. If 非合法な位置に着手が試みられた場合、the 着手実行関数 shall エラーを返す
6. The 着手実行関数 shall 実行時間1.5マイクロ秒以内で完了する（ARM64実測値ベース）

### 要件 4: ゲーム終了判定

**目的:** ゲーム制御者として、ゲームが終了したか、またはパスが必要かを判定したい。これにより、正しいゲームフローを実現する。

#### 受入基準

1. When 現在の手番で合法手がない際、the ゲーム状態判定関数 shall パス状態を返す
2. When 両者とも合法手がない際、the ゲーム状態判定関数 shall ゲーム終了を返す
3. When 全64マスが埋まった際、the ゲーム状態判定関数 shall ゲーム終了を返す
4. When ゲーム終了時、the 最終スコア算出関数 shall 黒石数と白石数の差を返す（正=黒勝ち、負=白勝ち）
5. The ゲーム状態判定関数 shall 手数カウンタを管理する（0-60手）

### 要件 5: BitBoard回転操作

**目的:** パターン評価の開発者として、盤面を4方向（0°, 90°, 180°, 270°）に回転できる機能が必要である。これにより、パターン抽出時の対称性を活用する。

#### 受入基準

1. The 回転関数 shall 盤面を90°回転した結果を返す（行列変換: (row, col) → (col, 7-row)）
2. The 回転関数 shall 盤面を180°回転した結果を返す（ARM64のREV命令を活用したビット順序反転）
3. The 回転関数 shall 盤面を270°回転した結果を返す（90°回転の3回適用と同等）
4. When 回転操作を実行する際、the 回転関数 shall 黒石と白石の両方のビットマスクを正しく変換する
5. The 回転関数 shall 回転後の盤面が元の盤面と同じゲーム状態を表現することを保証する
6. The 回転関数 shall 実行時間200ナノ秒以内で完了する（ARM64専用最適化）

### 要件 6: パターン定義の読み込み

**目的:** システム初期化担当者として、パターン定義ファイル（patterns.csv）から14パターンの定義を読み込みたい。これにより、評価関数で使用するパターン情報を取得する。

#### 受入基準

1. When システム起動時、the パターン定義ローダー shall patterns.csvから14パターン（P01-P14）の定義を読み込む
2. The パターン定義ローダー shall 各パターンについてID、セル数k、セル位置リストを保持する
3. If patterns.csvが存在しない場合、the パターン定義ローダー shall エラーメッセージを表示して終了する
4. The パターン定義ローダー shall 各パターンのセル位置が0-63の範囲内であることを検証する
5. The パターン定義ローダー shall 読み込んだパターン定義をグローバルに参照可能な形で保持する
6. The Pattern構造体 shall 固定長配列でセル位置を保持し、ヒープアロケーションを回避する

### 要件 7: パターンインデックス抽出

**目的:** 評価関数の開発者として、与えられた盤面とパターンから3進数インデックスを抽出したい。これにより、評価テーブルへのアクセスキーを生成する。

#### 受入基準

1. When 盤面とパターンが与えられた際、the パターンインデックス抽出関数 shall 3進数（0=空、1=黒、2=白）でインデックスを計算する
2. The パターンインデックス抽出関数 shall パターンの各セルについて石の状態をビットマスクから取得する
3. When 白黒反転フラグがtrueの際、the パターンインデックス抽出関数 shall 黒と白の値を入れ替える（1↔2）
4. The パターンインデックス抽出関数 shall 計算結果が0から3^k-1の範囲内であることを保証する（kはパターンのセル数）
5. The パターンインデックス抽出関数 shall 同一盤面・同一パターンに対して常に同じインデックスを返す（決定性）
6. The パターンインデックス抽出関数 shall ブランチレス実装で分岐予測ミスを最小化する

### 要件 8: 4方向パターン抽出

**目的:** 評価関数の開発者として、1つの盤面から4方向の回転で56個のパターンインスタンスを抽出したい。これにより、対称性を考慮した評価を実現する。

#### 受入基準

1. When 盤面が与えられた際、the 全パターン抽出関数 shall 4方向（0°, 90°, 180°, 270°）に回転した盤面を生成する
2. The 全パターン抽出関数 shall 各回転方向について14パターンのインデックスを抽出する（合計56個）
3. When 90°または270°回転の際、the 全パターン抽出関数 shall 白黒反転フラグをtrueに設定する
4. When 0°または180°回転の際、the 全パターン抽出関数 shall 白黒反転フラグをfalseに設定する
5. The 全パターン抽出関数 shall 56個のインデックスを配列として返す（順序: 回転方向×パターンID）
6. The 全パターン抽出関数 shall 実行時間25マイクロ秒以内で完了する（キャッシュミス率を考慮）

### 要件 9: 評価テーブル管理

**目的:** 評価システムの開発者として、14パターン × 30ステージ × 3^kエントリの評価テーブルを管理したい。これにより、パターン評価値を保存・参照する。

#### 受入基準

1. The 評価テーブル構造体 shall Structure of Arrays（SoA）形式で[ステージ][平坦化配列]の2次元構造でデータを保持する
2. When システム初期化時、the 評価テーブル shall 全エントリを32768（石差0に相当）に初期化する
3. The 評価テーブル shall 各パターンについて3^k個のエントリを割り当てる（kはセル数）
4. The 評価テーブル shall 30ステージ（0-29）それぞれに独立したテーブルを持つ
5. The 評価テーブル shall メモリ使用量約80MB以内に収める（SoA変換のパディング込み）
6. The 評価テーブル shall 同じステージの全パターンデータを連続メモリ配置し、キャッシュヒット率を向上させる
7. The 評価テーブル shall パターンオフセット配列で各パターンの開始位置を管理する

### 要件 10: スコア型変換

**目的:** 評価関数の開発者として、u16型の評価値と浮動小数点の石差を相互変換したい。これにより、メモリ効率と計算精度のバランスを取る。

#### 受入基準

1. The u16→石差変換関数 shall 式`(value - 32768.0) / 256.0`を使用してf32型の石差を返す
2. The 石差→u16変換関数 shall 式`clamp(score × 256.0 + 32768.0, 0.0, 65535.0)`を使用してu16型の値を返す
3. The 変換関数 shall u16値0を石差-128.0にマッピングする
4. The 変換関数 shall u16値32768を石差0.0にマッピングする
5. The 変換関数 shall u16値65535を石差+127.996にマッピングする
6. The 変換関数 shall ARM NEONによるベクトル化変換をサポートする（8個同時変換）

### 要件 11: 基本評価関数

**目的:** ゲームAI開発者として、与えられた盤面の評価値を計算したい。これにより、後続フェーズで探索・学習に使用する評価基盤を提供する。

#### 受入基準

1. When 盤面とステージが与えられた際、the 評価関数 shall 56個のパターンインスタンスから評価値を取得し合計する
2. The 評価関数 shall ステージを手数÷2で計算する（0-29の範囲）
3. When 現在の手番が白の際、the 評価関数 shall 合計評価値の符号を反転する
4. The 評価関数 shall 各パターンインスタンスのu16値をf32石差に変換してから合計する
5. The 評価関数 shall 初期盤面に対して評価値0.0付近を返す（中立な初期値）
6. The 評価関数 shall 実行時間35マイクロ秒以内で完了する（キャッシュ最適化とプリフェッチ）
7. The 評価関数 shall 次回アクセス位置をプリフェッチし、メモリレイテンシを隠蔽する

### 要件 12: ステージ管理

**目的:** 学習システムの開発者として、ゲームの進行度を30段階のステージで管理したい。これにより、序盤・中盤・終盤で異なる評価テーブルを使用する。

#### 受入基準

1. The ステージ計算関数 shall 手数を2で割った値をステージ番号として返す（0-1手→ステージ0、2-3手→ステージ1、...、58-59手→ステージ29）
2. The ステージ計算関数 shall 手数60（ゲーム終了）の場合にステージ29を返す
3. The ステージ計算関数 shall 0-29の範囲内の整数を返すことを保証する
4. When 評価関数呼び出し時、the システム shall 現在の手数から正しいステージを計算する
5. The ステージ管理 shall 各ステージごとに独立した評価テーブルへのアクセスを可能にする

### 要件 13: メモリ効率と型安全性

**目的:** システムアーキテクトとして、Phase 1実装がメモリ効率的で型安全であることを保証したい。これにより、長時間の学習実行時の安定性を確保する。

#### 受入基準

1. The BitBoard実装 shall 1盤面あたり16バイト以内のメモリを使用する（u64×2 + 手番情報）
2. The パターンテーブル shall 総メモリ使用量80MB以内に収める（SoA変換のパディング込み）
3. The 全データ構造 shall Rust の所有権システムに準拠し、メモリリークを防ぐ
4. The 数値計算 shall オーバーフローやアンダーフローを適切に処理する（clamp使用）
5. The 公開API shall 不正な引数（範囲外の値など）に対してResult型でエラーを返す
6. The Pattern構造体 shall ヒープアロケーションを回避し、スタック上に配置する

### 要件 14: ユニットテストとデバッグ支援

**目的:** 開発者として、実装の正当性を検証するテストとデバッグ機能が必要である。これにより、Phase 1の品質を保証する。

#### 受入基準

1. The BitBoard実装 shall 初期盤面の正当性を検証するテストを含む
2. The 合法手生成 shall 既知の盤面状態での期待される合法手を検証するテストを含む
3. The パターン抽出 shall 対称性（回転後の評価値一致）を検証するテストを含む
4. The BitBoard shall 盤面を人間可読な形式（8×8グリッド）で表示する関数を提供する
5. When デバッグモード時、the 各関数 shall 中間状態をログ出力する機能を提供する
6. The 各主要機能 shall Criterion crateによるマイクロベンチマークを含む

### 要件 15: パフォーマンス要件

**目的:** システムアーキテクトとして、Phase 1の実装が後続フェーズの性能要件を満たす基礎を提供したい。これにより、100万局の学習を現実的な時間で完了できる。

#### 受入基準

1. The 合法手生成 shall 平均500ナノ秒以内で実行される（ARM64実測値ベース）
2. The パターンインデックス抽出（56個） shall 平均25マイクロ秒以内で実行される（キャッシュミス率30-40%を想定）
3. The 評価関数（56パターン合計） shall 平均35マイクロ秒以内で実行される（プリフェッチとSoA最適化）
4. The 着手実行（石の反転含む） shall 平均1.5マイクロ秒以内で実行される
5. The ビットボード回転 shall 平均200ナノ秒以内で実行される（ARM64 REV命令活用）
6. The キャッシュミス率 shall 評価関数実行時に30-40%以下を維持する（perfツールで測定）

### 要件 16: ARM64最適化

**目的:** パフォーマンスエンジニアとして、ARM64アーキテクチャ固有の最適化を実装したい。これにより、OCI Ampere A1の性能を最大限活用する。

#### 受入基準

1. The Cargo.toml shall `target-cpu = "neoverse-n1"` を指定し、Neoverse N1固有の命令を有効化する
2. The Cargo.toml shall `target-feature = "+neon,+crc,+crypto"` を指定し、SIMD拡張を有効化する
3. The 回転関数 shall ARM64のREV命令を使用した180度回転を実装する
4. The 合法手生成 shall ARM64のCLZ/CTZ命令を活用する
5. The スコア変換 shall 可能な場合にNEON SIMD命令でベクトル化する
6. The 評価関数 shall `__builtin_prefetch`によるプリフェッチディレクティブを使用する

## 非機能要件

### NFR-1: プラットフォーム互換性
The Phase 1実装 shall ARM64（OCI Ampere A1、Neoverse N1）を主要ターゲットとし、x86_64での動作も維持する

### NFR-2: コンパイル設定
The プロジェクト shall Cargo.tomlにリリースビルドの最適化設定（opt-level=3, lto="fat", target-cpu="neoverse-n1"）を含む

### NFR-3: ドキュメント
The 全公開関数 shall Rustdocコメントで目的と使用例を記述する

### NFR-4: エラーハンドリング
The Phase 1実装 shall 回復可能なエラーにはResult型を、回復不可能なエラーにはpanicを使用する

### NFR-5: 段階的ベンチマーク
The 実装 shall 各主要タスク完了時にマイクロベンチマークを実施し、早期にボトルネックを特定する

## 補足

### Phase 1完了の定義
- 全16要件の受入基準を満たす
- 全ユニットテストが成功する
- パフォーマンス要件を満たす（要件15、要件16）
- ドキュメントが整備されている
- perfツールによるキャッシュミス率測定で30-40%以下を確認

### Phase 2への引き継ぎ事項
- BitBoard操作の全API
- 評価テーブル構造体（SoA形式）
- パターン抽出関数
- 基本評価関数のインターフェース
- パフォーマンスレポート（実測値、キャッシュミス率、ボトルネック分析）

### 依存関係
- patterns.csv（パターン定義ファイル）が事前に準備されていること
- Rust 1.70以上の開発環境
- ARM64環境（OCI Ampere A1）での実行とベンチマーク
- perfツール（Linuxパフォーマンス測定）のインストール
